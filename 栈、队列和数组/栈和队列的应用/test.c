#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

//栈的应用 ---- 括号匹配

//void test()
//{
//	int arr[10][10];
//	int x = 10 * (20 * (1 + 1) - (3 - 2));
//	//printf("hh\n" //当不写括号时，编译器能检测出来
//	//在编译时，编译器会进行括号匹配
//}

//（（（（ ））））
// 1 2 3 4 4 3 2 1
//从左往右扫描，最后出现的左括号优先被匹配（LIFO）
// 把左括号依次压入栈中，最晚压入的，先出
// 遇到左括号就入栈，遇到右括号就“消耗”一个左括号，查看是否能匹配上

//具体算法
//#define MaxSize 10
//typedef struct {
//	char data[MaxSize];
//	int top;	
//}SqStack;
//
//int brackerCheck(char str[], int length)
//{
//	SqStack S;	//初始化一个栈
//	for (int i = 0; i < length; i++)
//	{
//		if (str[i] == '(' || str[i] == '{' || str[i] == '[')
//		{
//			Push(&S, str[i]);
//		}
//		else
//		{
//			if (StackEmpty(S))//扫描到右括号且当前栈空
//			{
//				return -999;
//			}
//			char topElem;
//			Pop(&S, &topElem); //栈不空就出栈
//			if (str[i] == ')' && topElem != '(')
//			{
//				return -999;
//			}
//			if (str[i] == ']' && topElem != '[')
//			{
//				return -999;
//			}
//			if (str[i] == '}' && topElem != '{')
//			{
//				return -999;
//			}
//		}
//	}	
//	if (StackEmpty(S))
//	{
//		return -9999;
//	}
//	return 1;
//}





// 栈的应用 ----- 表达式求值
//（（15/（7-（1+1）））*3）-（2+（1+1））	
//有三个部分组成：操作符、运算符、界限符 （界限符是不可缺少的，反映了计算的顺序，
// 即去掉括号会导致运算顺序发生改变，导致结果改变）


//一个波兰数学家想到：可不可以不用界限符也能无歧义的表达运算顺序
//Reverse Polish notation  逆波兰表达式==后缀表达式
//Polish notation          波兰表达式==前缀表达式

//中缀表达式就是把运算符放在两个操作数的中间：a+b
//后缀表达式就是把运算符放在两个操作数的后边：  ab+ (操作数的顺序不能改变，
//												   虽然+不影响结果，但是减法、除法会)
//前缀表达式就是把运算符放在两个操作数的前边：+ab

//中缀表达式           后缀表达式                    前缀表达式
     //a+b                ab+                          +ab

     //a+b-c              ab+ c-  （ a bc - +）        - +ab c
     //                         

     //a+b-c*d            ab+ cd* -                    +ab *cd


//中缀表达式转后缀表达式（手算）
//1.确定中缀表达式中各个运算符的运算顺序
//2.选择下一个运算符 按照【左操作数，右操作数，运算符】得到方式组合成一个新的操作数
// 运算顺序不唯一，因此对应的后缀表达式也不唯一
//3.如果还有运算符没被处理，就继续2 .

//（（15/（7-（1+1）））*3）        -（2+（1+1））	
//             1 1 +                       1 1 +
//             7 1 1 + -                 2 1 1 + + 
//            15 7 1 1 + - / 
//            15 7 1 1 + - /  3 * 2 1 1 + + -

//后缀表达式中 加法第一个生效 减法第二，乘法第三，除法第四


// 运算顺序不唯一，因此对应的后缀表达式也不唯一
//A+B * (C-D) - E/F
//1. ABCD-*+EF/-
//2. ABCD-*EF/-+
//客观来讲以上两种写法都正确，但是“计算”的结果是前者
//左右先原则：只要左边的运算符能先算出来，就先计算左边的（可保证运算顺序唯一）
//

//得到后缀表达式怎么通过这个表达式计算出最终结果
//    15 7 1 1 + - /  3 * 2 1 1 + + -
