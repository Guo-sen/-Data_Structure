#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

//栈的应用 ---- 括号匹配

//void test()
//{
//	int arr[10][10];
//	int x = 10 * (20 * (1 + 1) - (3 - 2));
//	//printf("hh\n" //当不写括号时，编译器能检测出来
//	//在编译时，编译器会进行括号匹配
//}

//（（（（ ））））
// 1 2 3 4 4 3 2 1
//从左往右扫描，最后出现的左括号优先被匹配（LIFO）
// 把左括号依次压入栈中，最晚压入的，先出
// 遇到左括号就入栈，遇到右括号就“消耗”一个左括号，查看是否能匹配上

//具体算法
//#define MaxSize 10
//typedef struct {
//	char data[MaxSize];
//	int top;	
//}SqStack;
//
//int brackerCheck(char str[], int length)
//{
//	SqStack S;	//初始化一个栈
//	for (int i = 0; i < length; i++)
//	{
//		if (str[i] == '(' || str[i] == '{' || str[i] == '[')
//		{
//			Push(&S, str[i]);
//		}
//		else
//		{
//			if (StackEmpty(S))//扫描到右括号且当前栈空
//			{
//				return -999;
//			}
//			char topElem;
//			Pop(&S, &topElem); //栈不空就出栈
//			if (str[i] == ')' && topElem != '(')
//			{
//				return -999;
//			}
//			if (str[i] == ']' && topElem != '[')
//			{
//				return -999;
//			}
//			if (str[i] == '}' && topElem != '{')
//			{
//				return -999;
//			}
//		}
//	}	
//	if (StackEmpty(S))
//	{
//		return -9999;
//	}
//	return 1;
//}





// 栈的应用 ----- 表达式求值
//（（15/（7-（1+1）））*3）-（2+（1+1））	
//有三个部分组成：操作符、运算符、界限符 （界限符是不可缺少的，反映了计算的顺序，
// 即去掉括号会导致运算顺序发生改变，导致结果改变）


//一个波兰数学家想到：可不可以不用界限符也能无歧义的表达运算顺序
//Reverse Polish notation  逆波兰表达式==后缀表达式
//Polish notation          波兰表达式==前缀表达式

//中缀表达式就是把运算符放在两个操作数的中间：a+b
//后缀表达式就是把运算符放在两个操作数的后边：  ab+ (操作数的顺序不能改变，
//												   虽然+不影响结果，但是减法、除法会)
//前缀表达式就是把运算符放在两个操作数的前边：+ab

//中缀表达式           后缀表达式                    前缀表达式
     //a+b                ab+                          +ab

     //a+b-c              ab+ c-  （ a bc - +）        - +ab c
     //                         

     //a+b-c*d            ab+ cd* -                    +ab *cd


//中缀表达式转后缀表达式（手算）
//1.确定中缀表达式中各个运算符的运算顺序
//2.选择下一个运算符 按照【左操作数，右操作数，运算符】得到方式组合成一个新的操作数
// 运算顺序不唯一，因此对应的后缀表达式也不唯一
//3.如果还有运算符没被处理，就继续2 .

//（（15/（7-（1+1）））*3）        -（2+（1+1））	
//             1 1 +                       1 1 +
//             7 1 1 + -                 2 1 1 + + 
//            15 7 1 1 + - / 
//            15 7 1 1 + - /  3 * 2 1 1 + + -

//后缀表达式中 加法第一个生效 减法第二，乘法第三，除法第四


// 运算顺序不唯一，因此对应的后缀表达式也不唯一
//A+B * (C-D) - E/F
//1. ABCD-*+EF/-
//2. ABCD-*EF/-+
//客观来讲以上两种写法都正确，但是“计算”的结果是前者
//左优先原则：只要左边的运算符能先算出来，就先计算左边的（可保证运算顺序唯一）
//

//中缀表达式转后缀表达式
//初始化一个栈用于保存暂时还不能确定运算顺序的运算符 
//从左到右处理各个数据元素，直到末尾，可能遇到三种情况
//1.碰到操作数。直接加入后缀表达式
//2.遇到界限符。遇到“（”直接入栈； 遇到“）”,则依次弹出栈内运算符，并加入后缀表达式
//直到弹出“(”为止。注意“（”不加入后缀表达式
//3.遇到运算符。则依次弹出栈中优先级高于或者等于当前运算符的所有运算符，并加入后缀表达式
//若碰到“（”或栈空，则把当前运算符入栈
//
// 按上述方法处理完所有字符后将栈中剩余运算符依次弹出，并加入后缀表达式








//栈在递归中的应用
//函数调用的特点：最后被调用的函数最先执行结束（LIFO）
//函数调用时，需要一个栈存储：
//1.调用返回地址  2.实参  3.局部变量




//得到后缀表达式怎么通过这个表达式计算出最终结果
//（（15/（7-（1+1）））*3）-（2+（1+1））	
//    15 7 1 1 + - /  3 * 2 1 1 + + -
//从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应的运算，合体为一个操作数

//特点，最后出现的操作数先被运算,后进先出(LIFO)

//算法实现
//1.从左往右扫描下一个元素，直到处理完所有元素
//2.若扫描到操作数则压入栈；并回到1；否则执行3
//3.若扫描到操作符，则弹出两个栈顶元素，执行相应的运算，运算结果压入栈，回到 1.
//后缀表达式先弹出的是右操作数

//注意：先出栈的是右操作数；若表达式合法，最后栈中会只留下一个元素，那就是最终结果
//现阶段 不需要太关注代码实现





//中缀表达式转前缀表达式
//手算：
//1.确定中缀表达式中各个运算符的运算顺序
//2.选择下一个运算符，按照【操作符，左操作数，右操作数】的方式组合成一个新的操作数
//3.如果还有运算符没有被处理，那就计算2
//右优先原则：只要右边的运算符能先计算，就优先算右边的

//A+B * (C-D) - E/F
// 
//   - +A  *B  - C D  / E F
// 
//      -   A+B*(C-D)    E/F 
//      A+B*(C-D)-E/F

//注意，前缀表达式运算先弹出的是左操作数

//用栈实现前缀表达式的计算
//1.从右往左扫描下一个元素，直到处理完所有的元素
//2.若扫描到操作数则压入栈，并且回到 1；否则执行3
//3.若扫描到运算符，则弹出两个栈顶元素，执行相应的运算，运算结果压入栈顶，回到1




//中缀表达式的计算（用栈实现）
//初始化两个栈，操作数栈和运算符栈
//若扫描到操作数，压入操作数栈
//若扫描到运算符或者界限符则按照（中缀转后缀）的相同逻辑压入运算符（期间也会弹出运算符
//每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压入操作数栈）


//队列的应用
// 树的层次遍历
// 图的广度优先遍历
//队列在操作系统中的应用：多个进程争抢着使用操作系统优先的资源时，
//（FCFS）先来先服务是一种常用策略







