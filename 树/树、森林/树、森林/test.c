//#define _CRT_SECURE_NO_WARNINGS 1
//#define MAX_TREE_SIZE 100 //树中最多结点
//#include<stdio.h>
//#include<stdlib.h>
//#include<string.h>
//#include<malloc.h>
//
////树的存储
////之前学的二叉树的存储，可以用数组下标和完全二叉树的序号对应。
////但一般的树，有几个子树是不确定的，只依靠数组下标，无法反映结点之间的逻辑关系（没有完全树的说法）
////可以用一个指针（非根节点的双亲指针=父节点在数组中的下标，根节点的双亲指针=-1）   //树的双亲存储
//typedef struct {  //树的结点定义
//	ElemType data; //数据元素
//	int parent; // 双亲位置域
//}PTNode;
//
//typedef struct { //树的类型定义
//	PTNode nodes[MAX_TREE_SIZE]; //双亲表示
//	int n;						//结点总数
//}PTree;
////这种双亲表示法除了可以用来存储树，也可以用来存储森林
//
////双亲表示法的优缺点
////优点：找双亲（父结点）很方便
////缺点：找孩子不方便，只能从头遍历
//
//
//
////孩子表示法（顺序+链式存储）
//
//struct CTNode {
//	int child;  //孩子结点在数组中的位置
//	struct CTNode* next; //下一个孩子
//};
//
//typedef struct { //每个树的结点包含一个链表指针，这个链表指针指向的链表存储了这个结点的孩子的编号
//	ElemType data;
//	struct CTNode* firstChild; //第一个孩子
//}CTBox;
//
//typedef struct {
//	CTBox nodes[MAX_TREE_SIZE];
//	int n, r; //结点数和根的位置
//}CTree;
//
////这种表示法可以存储森林
////孩子表示法的优缺点
////优点：找某个结点的孩子方便（因为结点还存储了一个指针，这个指针指向了存储孩子编号的链表）
////缺点：找父亲不方便，只能遍历每个链表
//
//
//
////孩子兄弟表示法（链式存储）
//typedef struct CSNode {
//	ElemType data;							 //数据域
//	struct CSNode* firstchild, * nextsibling;  //第一个孩子和右兄弟指针	
//}CSNode, * CSTree;
////和二叉树类似，采用二叉链表实现
////也可以存储森林（可以把森林中各个根节点看成兄弟结点）
//




//树、森林、二叉树的转换

//树->二叉树：本质上就是问如何用孩子兄弟表示法存储这棵树（技巧：按树的层序处理每个节点）
//处理每个结点的方法：如果当前处理结点有孩子，就把所有孩子用右指针串成一个糖葫芦，并且把第一个孩子挂在当前结点的左指针

//森林->二叉树：先把所有树的根结点用右指针串成糖葫芦，然后按森林的层序依次处理每个结点


//二叉树->树：先画出树的根结点，从树的根结点开始，按树的层序恢复每个结点的孩子
//如何恢复一个一个结点的孩子：在二叉树中，如果当前处理的结点有左孩子，
//就把左孩子和一整串右指针糖葫芦拆下来，按顺序挂在当前结点的下方

//二叉树转换成森林：注意多棵树的根节点就是二叉树的根结点右边的糖葫芦

//树（先根、后根、层序）、森林（先序、中序）的遍历

//树的先根遍历序列和把树转换成二叉树后 先序遍历得到的遍历序列相同
//树的后根遍历序列和把树转换成二叉树后 中序遍历得到的遍历序列相同
//树的层次遍历（用队列实现）
//树的先根遍历和后跟遍历可以称为树的深度优先遍历 树的层次优先遍历可以称为树的广度优先遍历

//森林的先序遍历效果等同于依次对各个子树进行 先根遍历
//森林的中序遍历效果等同于依次对各个子树进行 后根遍历